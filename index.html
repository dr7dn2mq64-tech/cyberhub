<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Liquid Glass Arcade Ultimate - å®Œæ•´ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        :root {
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.25);
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            --neon-pink: #ff2d95;
            --neon-blue: #00f3ff;
            --neon-purple: #b300ff;
            --neon-green: #39ff14;
            --neon-yellow: #fff01f;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .bg-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            z-index: -2;
            transition: opacity 0.5s;
        }

        .bg-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(0,0,0,0.6));
            backdrop-filter: blur(3px);
            z-index: -1;
        }

        .ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }

        .ui-container > * {
            pointer-events: auto;
        }

        /* é¡¶éƒ¨å¯¼èˆª - Liquid Glass */
        .top-bar {
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(180%);
            border-bottom: 1px solid var(--glass-border);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--glass-shadow);
            z-index: 100;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: 900;
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0,243,255,0.5);
        }

        .stats-display {
            display: flex;
            gap: 2rem;
            font-size: 1.2rem;
        }

        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 0.5rem 1.5rem;
            border-radius: 20px;
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 120px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.7;
            display: block;
            margin-bottom: 0.2rem;
        }

        .stat-value {
            font-weight: bold;
            color: var(--neon-yellow);
            font-size: 1.3rem;
        }

        /* æ¸¸æˆé€‰æ‹©æ  */
        .game-selector {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border-bottom: 1px solid var(--glass-border);
            padding: 1rem;
            overflow-x: auto;
            white-space: nowrap;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }

        .game-selector::-webkit-scrollbar {
            display: none;
        }

        .game-btn {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            margin: 0 0.5rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.8);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.95rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .game-btn:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .game-btn.active {
            background: linear-gradient(135deg, rgba(255,45,149,0.8), rgba(179,0,255,0.8));
            border-color: transparent;
            color: #fff;
            box-shadow: 0 0 20px rgba(255,45,149,0.4);
        }

        /* ä¸»æ¸¸æˆåŒºåŸŸ */
        .game-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            position: relative;
        }

        .game-container {
            width: 100%;
            max-width: 1000px;
            height: 100%;
            max-height: 700px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px) saturate(150%);
            border: 1px solid var(--glass-border);
            border-radius: 30px;
            box-shadow: var(--glass-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .game-header {
            padding: 1.5rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .game-title {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .game-controls {
            display: flex;
            gap: 1rem;
        }

        .control-btn {
            padding: 0.6rem 1.2rem;
            background: linear-gradient(135deg, rgba(0,243,255,0.8), rgba(0,100,255,0.8));
            border: none;
            color: #fff;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,243,255,0.3);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,243,255,0.5);
        }

        .control-btn.secondary {
            background: rgba(255,255,255,0.1);
            box-shadow: none;
        }

        /* Canvas åŒºåŸŸ */
        .canvas-wrapper {
            flex: 1;
            position: relative;
            margin: 0 1.5rem 1.5rem;
            background: rgba(0,0,0,0.5);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* æ¸¸æˆè¦†ç›–å±‚ */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .game-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .overlay-title {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 900;
        }

        .overlay-score {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            color: rgba(255,255,255,0.8);
        }

        /* ç§»åŠ¨ç«¯æ§åˆ¶æç¤º */
        .mobile-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            color: rgba(255,255,255,0.7);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        @media (max-width: 768px) {
            .mobile-hint { opacity: 1; }
            .top-bar { padding: 0.8rem; }
            .logo { font-size: 1.2rem; }
            .stats-display { gap: 0.5rem; font-size: 0.9rem; }
            .stat-box { padding: 0.3rem 0.8rem; min-width: 80px; }
            .game-title { font-size: 1.3rem; }
            .game-area { padding: 0.5rem; }
            .game-container { border-radius: 20px; }
            .game-btn { padding: 0.6rem 1rem; font-size: 0.8rem; margin: 0 0.3rem; }
        }
    </style>
</head>
<body>
    <!-- åŠ¨æ€èƒŒæ™¯ -->
    <div class="bg-layer" id="bgLayer" style="background-image: url('https://images.unsplash.com/photo-1550684848-fac1c5b4e853?w=1920&q=80');"></div>
    <div class="bg-overlay"></div>

    <div class="ui-container">
        <!-- é¡¶éƒ¨ä¿¡æ¯æ  -->
        <div class="top-bar">
            <div class="logo">ğŸ® LIQUID ARCADE</div>
            <div class="stats-display">
                <div class="stat-box">
                    <span class="stat-label">å½“å‰å¾—åˆ†</span>
                    <span class="stat-value" id="currentScore">0</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">æ¸¸æˆç­‰çº§</span>
                    <span class="stat-value" id="currentLevel">1</span>
                </div>
                <div class="stat-box">
                    <span class="stat-label">å†å²æœ€é«˜</span>
                    <span class="stat-value" id="highScore">0</span>
                </div>
            </div>
        </div>

        <!-- æ¸¸æˆé€‰æ‹©å™¨ -->
        <div class="game-selector" id="gameSelector">
            <button class="game-btn active" data-game="tetris">ä¿„ç½—æ–¯æ–¹å—</button>
            <button class="game-btn" data-game="snake">è´ªåƒè›‡</button>
            <button class="game-btn" data-game="pacman">åƒè±†äºº</button>
            <button class="game-btn" data-game="breakout">æ‰“ç –å—</button>
            <button class="game-btn" data-game="shooter">å¤ªç©ºå°„å‡»</button>
            <button class="game-btn" data-game="pinball">å¼¹çƒå°</button>
            <button class="game-btn" data-game="racing">åƒç´ èµ›è½¦</button>
            <button class="game-btn" data-game="flappy">Flappy Bird</button>
            <button class="game-btn" data-game="puzzle2048">2048</button>
            <button class="game-btn" data-game="minesweeper">æ‰«é›·</button>
            <button class="game-btn" data-game="tictactoe">äº•å­—æ£‹</button>
            <button class="game-btn" data-game="memory">è®°å¿†ç¿»ç‰Œ</button>
            <button class="game-btn" data-game="whackamole">æ‰“åœ°é¼ </button>
            <button class="game-btn" data-game="rhythm">é’¢ç´å—</button>
            <button class="game-btn" data-game="eggcatch">æ¥é¸¡è›‹</button>
            <button class="game-btn" data-game="pong">ä¹’ä¹“çƒ</button>
            <button class="game-btn" data-game="colorrush">è‰²å½©æé€Ÿ</button>
            <button class="game-btn" data-game="redalert">çº¢è­¦95</button>
            <button class="game-btn" data-game="particles">ç²’å­ç»˜æ¿</button>
        </div>

        <!-- æ¸¸æˆä¸»åŒºåŸŸ -->
        <div class="game-area">
            <div class="game-container">
                <div class="game-header">
                    <h2 class="game-title" id="gameTitle">ä¿„ç½—æ–¯æ–¹å—</h2>
                    <div class="game-controls">
                        <button class="control-btn" onclick="gameEngine.restart()">æ–°æ¸¸æˆ</button>
                        <button class="control-btn secondary" onclick="gameEngine.togglePause()">æš‚åœ</button>
                        <button class="control-btn secondary" onclick="gameEngine.changeBackground()">æ¢èƒŒæ™¯</button>
                    </div>
                </div>
                
                <div class="canvas-wrapper">
                    <canvas id="gameCanvas"></canvas>
                    <div class="game-overlay" id="gameOverlay">
                        <h3 class="overlay-title" id="overlayTitle">æ¸¸æˆç»“æŸ</h3>
                        <p class="overlay-score" id="overlayScore">æœ€ç»ˆå¾—åˆ†: 0</p>
                        <button class="control-btn" onclick="gameEngine.restart()" style="font-size: 1.2rem; padding: 1rem 2rem;">é‡æ–°å¼€å§‹</button>
                    </div>
                    <div class="mobile-hint" id="mobileHint">ç§»åŠ¨ç«¯ï¼šç‚¹å‡»å±å¹•å·¦å³ä¾§ç§»åŠ¨ï¼Œç‚¹å‡»ä¸­å¤®æ—‹è½¬/å°„å‡»</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * Liquid Glass Arcade - å®Œæ•´æ¸¸æˆå¼•æ“
         * é‡‡ç”¨ä¸¥æ ¼çš„é¢å‘å¯¹è±¡è®¾è®¡ï¼Œç¡®ä¿æ¯æ¬¾æ¸¸æˆç‹¬ç«‹è¿è¡Œï¼ŒçŠ¶æ€å®Œå…¨éš”ç¦»
         */

        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.currentGame = null;
                this.currentGameId = 'tetris';
                this.isPaused = false;
                this.score = 0;
                this.level = 1;
                this.highScores = JSON.parse(localStorage.getItem('liquidArcadeScores')) || {};
                this.animationId = null;
                this.lastTime = 0;
                this.backgrounds = [
                    'https://images.unsplash.com/photo-1550684848-fac1c5b4e853?w=1920&q=80',
                    'https://images.unsplash.com/photo-1579546929518-9e396f3cc809?w=1920&q=80',
                    'https://images.unsplash.com/photo-1558591710-4b4a1ae0f04d?w=1920&q=80',
                    'https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?w=1920&q=80',
                    'https://images.unsplash.com/photo-1614850523459-c2f4c699c52e?w=1920&q=80'
                ];
                this.bgIndex = 0;
                
                this.initEventListeners();
                this.resize();
                this.loadGame('tetris');
                
                window.addEventListener('resize', () => this.resize());
            }

            initEventListeners() {
                // æ¸¸æˆé€‰æ‹©æŒ‰é’®
                document.querySelectorAll('.game-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.game-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.loadGame(e.target.dataset.game);
                        document.getElementById('gameTitle').textContent = e.target.textContent;
                    });
                });

                // é”®ç›˜äº‹ä»¶
                window.addEventListener('keydown', (e) => this.handleInput(e));
                
                // è§¦æ‘¸/é¼ æ ‡äº‹ä»¶ç”±å…·ä½“æ¸¸æˆæ³¨å†Œï¼Œè¿™é‡Œåªå¤„ç†å…¨å±€çš„
            }

            resize() {
                const wrapper = document.querySelector('.canvas-wrapper');
                this.canvas.width = wrapper.clientWidth;
                this.canvas.height = wrapper.clientHeight;
                if (this.currentGame && this.currentGame.resize) {
                    this.currentGame.resize();
                }
            }

            loadGame(gameId) {
                // æ¸…ç†æ—§æ¸¸æˆ
                if (this.currentGame) {
                    this.currentGame.destroy();
                }
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }

                this.currentGameId = gameId;
                this.score = 0;
                this.level = 1;
                this.isPaused = false;
                this.updateUI();
                this.hideOverlay();

                // å®ä¾‹åŒ–æ–°æ¸¸æˆ
                switch(gameId) {
                    case 'tetris': this.currentGame = new TetrisGame(this); break;
                    case 'snake': this.currentGame = new SnakeGame(this); break;
                    case 'pacman': this.currentGame = new PacmanGame(this); break;
                    case 'breakout': this.currentGame = new BreakoutGame(this); break;
                    case 'shooter': this.currentGame = new ShooterGame(this); break;
                    case 'pinball': this.currentGame = new PinballGame(this); break;
                    case 'racing': this.currentGame = new RacingGame(this); break;
                    case 'flappy': this.currentGame = new FlappyGame(this); break;
                    case 'puzzle2048': this.currentGame = new Game2048(this); break;
                    case 'minesweeper': this.currentGame = new MinesweeperGame(this); break;
                    case 'tictactoe': this.currentGame = new TicTacToeGame(this); break;
                    case 'memory': this.currentGame = new MemoryGame(this); break;
                    case 'whackamole': this.currentGame = new WhackAMoleGame(this); break;
                    case 'rhythm': this.currentGame = new RhythmGame(this); break;
                    case 'eggcatch': this.currentGame = new EggCatchGame(this); break;
                    case 'pong': this.currentGame = new PongGame(this); break;
                    case 'colorrush': this.currentGame = new ColorRushGame(this); break;
                    case 'redalert': this.currentGame = new RedAlertGame(this); break;
                    case 'particles': this.currentGame = new ParticlesGame(this); break;
                }

                if (this.currentGame) {
                    this.currentGame.init();
                    this.gameLoop(0);
                }
            }

            gameLoop(timestamp) {
                if (!this.isPaused && this.currentGame) {
                    const deltaTime = timestamp - this.lastTime;
                    this.currentGame.update(deltaTime, timestamp);
                    this.currentGame.render();
                }
                this.lastTime = timestamp;
                this.animationId = requestAnimationFrame((t) => this.gameLoop(t));
            }

            handleInput(e) {
                if (this.currentGame && this.currentGame.handleInput) {
                    this.currentGame.handleInput(e);
                }
            }

            restart() {
                this.loadGame(this.currentGameId);
            }

            togglePause() {
                this.isPaused = !this.isPaused;
            }

            addScore(points) {
                this.score += points;
                this.updateUI();
            }

            setLevel(lvl) {
                this.level = lvl;
                this.updateUI();
            }

            updateUI() {
                document.getElementById('currentScore').textContent = this.score;
                document.getElementById('currentLevel').textContent = this.level;
                
                const high = this.highScores[this.currentGameId] || 0;
                if (this.score > high) {
                    this.highScores[this.currentGameId] = this.score;
                    localStorage.setItem('liquidArcadeScores', JSON.stringify(this.highScores));
                }
                document.getElementById('highScore').textContent = Math.max(high, this.score);
            }

            gameOver(won = false) {
                this.isPaused = true;
                document.getElementById('overlayTitle').textContent = won ? 'ğŸ‰ æ­å–œé€šå…³!' : 'æ¸¸æˆç»“æŸ';
                document.getElementById('overlayTitle').style.background = won ? 
                    'linear-gradient(45deg, #39ff14, #00f3ff)' : 
                    'linear-gradient(45deg, #ff2d95, #ff6600)';
                document.getElementById('overlayScore').textContent = `æœ€ç»ˆå¾—åˆ†: ${this.score}`;
                document.getElementById('gameOverlay').classList.add('show');
            }

            hideOverlay() {
                document.getElementById('gameOverlay').classList.remove('show');
            }

            changeBackground() {
                this.bgIndex = (this.bgIndex + 1) % this.backgrounds.length;
                document.getElementById('bgLayer').style.backgroundImage = 
                    `url('${this.backgrounds[this.bgIndex]}')`;
            }
        }

        // ==================== æ¸¸æˆåŸºç±» ====================
        class BaseGame {
            constructor(engine) {
                this.engine = engine;
                this.canvas = engine.canvas;
                this.ctx = engine.ctx;
                this.width = canvas.width;
                this.height = canvas.height;
                this.bindings = [];
            }

            init() {
                this.setupInputs();
            }

            resize() {
                this.width = this.canvas.width;
                this.height = this.canvas.height;
            }

            setupInputs() {
                // å­ç±»é‡å†™
            }

            bindEvent(element, event, handler) {
                element.addEventListener(event, handler);
                this.bindings.push({element, event, handler});
            }

            destroy() {
                // æ¸…ç†æ‰€æœ‰äº‹ä»¶ç›‘å¬
                this.bindings.forEach(({element, event, handler}) => {
                    element.removeEventListener(event, handler);
                });
                this.bindings = [];
            }

            update(deltaTime, timestamp) {}
            render() {}
            handleInput(e) {}
        }

        // ==================== 1. ä¿„ç½—æ–¯æ–¹å— ====================
        class TetrisGame extends BaseGame {
            init() {
                super.init();
                this.cols = 10;
                this.rows = 20;
                this.blockSize = 30;
                this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                this.pieces = [
                    [[1,1,1,1]],
                    [[1,1,1],[0,1,0]],
                    [[1,1,1],[1,0,0]],
                    [[1,1,1],[0,0,1]],
                    [[1,1],[1,1]],
                    [[0,1,1],[1,1,0]],
                    [[1,1,0],[0,1,1]]
                ];
                this.colors = ['#00f3ff','#b300ff','#ff2d95','#39ff14','#fff01f','#ff6600','#ff0066'];
                this.currentPiece = this.newPiece();
                this.dropInterval = 1000;
                this.lastDrop = 0;
                this.offsetX = (this.width - this.cols * this.blockSize) / 2;
                this.offsetY = (this.height - this.rows * this.blockSize) / 2;
            }

            newPiece() {
                const type = Math.floor(Math.random() * this.pieces.length);
                return {
                    x: Math.floor(this.cols / 2) - 1,
                    y: 0,
                    shape: this.pieces[type],
                    color: type
                };
            }

            rotate(piece) {
                const newShape = piece.shape[0].map((_, i) => 
                    piece.shape.map(row => row[i]).reverse()
                );
                return {...piece, shape: newShape};
            }

            collision(piece, dx=0, dy=0) {
                for(let y=0; y<piece.shape.length; y++) {
                    for(let x=0; x<piece.shape[y].length; x++) {
                        if(piece.shape[y][x]) {
                            const nx = piece.x + x + dx;
                            const ny = piece.y + y + dy;
                            if(nx < 0 || nx >= this.cols || ny >= this.rows) return true;
                            if(ny >= 0 && this.board[ny][nx]) return true;
                        }
                    }
                }
                return false;
            }

            merge() {
                this.currentPiece.shape.forEach((row, y) => {
                    row.forEach((val, x) => {
                        if(val) {
                            const ny = this.currentPiece.y + y;
                            if(ny >= 0) this.board[ny][this.currentPiece.x + x] = this.currentPiece.color + 1;
                        }
                    });
                });
            }

            clearLines() {
                let lines = 0;
                for(let y=this.rows-1; y>=0; y--) {
                    if(this.board[y].every(cell => cell !== 0)) {
                        this.board.splice(y, 1);
                        this.board.unshift(Array(this.cols).fill(0));
                        lines++;
                        y++;
                    }
                }
                if(lines > 0) {
                    this.engine.addScore(lines * 100 * this.engine.level);
                    this.engine.setLevel(Math.floor(this.engine.score / 1000) + 1);
                    this.dropInterval = Math.max(100, 1000 - (this.engine.level - 1) * 100);
                }
            }

            update(deltaTime, timestamp) {
                if(timestamp - this.lastDrop > this.dropInterval) {
                    if(!this.collision(this.currentPiece, 0, 1)) {
                        this.currentPiece.y++;
                    } else {
                        this.merge();
                        this.clearLines();
                        this.currentPiece = this.newPiece();
                        if(this.collision(this.currentPiece)) {
                            this.engine.gameOver();
                        }
                    }
                    this.lastDrop = timestamp;
                }
            }

            render() {
                // èƒŒæ™¯
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ç½‘æ ¼
                this.ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                this.ctx.lineWidth = 1;
                for(let i=0; i<=this.cols; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.offsetX + i*this.blockSize, this.offsetY);
                    this.ctx.lineTo(this.offsetX + i*this.blockSize, this.offsetY + this.rows*this.blockSize);
                    this.ctx.stroke();
                }
                for(let i=0; i<=this.rows; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.offsetX, this.offsetY + i*this.blockSize);
                    this.ctx.lineTo(this.offsetX + this.cols*this.blockSize, this.offsetY + i*this.blockSize);
                    this.ctx.stroke();
                }

                // ç»˜åˆ¶å·²å›ºå®šçš„æ–¹å—
                this.board.forEach((row, y) => {
                    row.forEach((colorIdx, x) => {
                        if(colorIdx) this.drawBlock(x, y, this.colors[colorIdx-1]);
                    });
                });

                // ç»˜åˆ¶å½“å‰æ–¹å—
                if(this.currentPiece) {
                    // é˜´å½±
                    let ghostY = this.currentPiece.y;
                    while(!this.collision({...this.currentPiece, y: ghostY+1})) ghostY++;
                    this.ctx.globalAlpha = 0.3;
                    this.currentPiece.shape.forEach((row, y) => {
                        row.forEach((val, x) => {
                            if(val) this.drawBlock(this.currentPiece.x+x, ghostY+y, this.colors[this.currentPiece.color], true);
                        });
                    });
                    this.ctx.globalAlpha = 1;
                    
                    // å®ä½“
                    this.currentPiece.shape.forEach((row, y) => {
                        row.forEach((val, x) => {
                            if(val) this.drawBlock(this.currentPiece.x+x, this.currentPiece.y+y, this.colors[this.currentPiece.color]);
                        });
                    });
                }
            }

            drawBlock(x, y, color, isGhost=false) {
                const px = this.offsetX + x * this.blockSize;
                const py = this.offsetY + y * this.blockSize;
                const size = this.blockSize - 2;
                
                if(!isGhost) {
                    const grad = this.ctx.createLinearGradient(px, py, px+size, py+size);
                    grad.addColorStop(0, color);
                    grad.addColorStop(1, color+'88');
                    this.ctx.fillStyle = grad;
                    this.ctx.shadowBlur = 15;
                    this.ctx.shadowColor = color;
                    this.ctx.fillRect(px+1, py+1, size, size);
                    this.ctx.shadowBlur = 0;
                    
                    // é«˜å…‰
                    this.ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    this.ctx.fillRect(px+3, py+3, size-6, 3);
                } else {
                    this.ctx.strokeStyle = color;
                    this.ctx.strokeRect(px+1, py+1, size, size);
                }
            }

            handleInput(e) {
                if(!this.currentPiece) return;
                switch(e.key) {
                    case 'ArrowLeft': 
                        if(!this.collision(this.currentPiece, -1, 0)) this.currentPiece.x--;
                        break;
                    case 'ArrowRight':
                        if(!this.collision(this.currentPiece, 1, 0)) this.currentPiece.x++;
                        break;
                    case 'ArrowDown':
                        if(!this.collision(this.currentPiece, 0, 1)) this.currentPiece.y++;
                        break;
                    case 'ArrowUp':
                        const rotated = this.rotate(this.currentPiece);
                        if(!this.collision(rotated)) this.currentPiece = rotated;
                        break;
                    case ' ':
                        while(!this.collision(this.currentPiece, 0, 1)) this.currentPiece.y++;
                        break;
                }
            }

            setupInputs() {
                this.bindEvent(this.canvas, 'touchstart', (e) => {
                    this.touchStartX = e.touches[0].clientX;
                    this.touchStartY = e.touches[0].clientY;
                });
                
                this.bindEvent(this.canvas, 'touchend', (e) => {
                    if(!this.touchStartX) return;
                    const dx = e.changedTouches[0].clientX - this.touchStartX;
                    const dy = e.changedTouches[0].clientY - this.touchStartY;
                    const absX = Math.abs(dx);
                    const absY = Math.abs(dy);
                    
                    if(absX < 30 && absY < 30) {
                        // ç‚¹å‡»-æ—‹è½¬
                        const rotated = this.rotate(this.currentPiece);
                        if(!this.collision(rotated)) this.currentPiece = rotated;
                    } else if(absX > absY) {
                        if(dx > 0 && !this.collision(this.currentPiece, 1, 0)) this.currentPiece.x++;
                        else if(dx < 0 && !this.collision(this.currentPiece, -1, 0)) this.currentPiece.x--;
                    } else {
                        if(dy > 0 && !this.collision(this.currentPiece, 0, 1)) this.currentPiece.y++;
                    }
                    this.touchStartX = null;
                });
            }
        }

        // ==================== 2. è´ªåƒè›‡ ====================
        class SnakeGame extends BaseGame {
            init() {
                super.init();
                this.gridSize = 25;
                this.tileCountX = Math.floor(this.width / this.gridSize);
                this.tileCountY = Math.floor(this.height / this.gridSize);
                this.reset();
                this.speed = 7;
                this.lastMove = 0;
            }

            reset() {
                this.snake = [{x: 10, y: 10}];
                this.direction = {x: 0, y: 0};
                this.nextDirection = {x: 0, y: 0};
                this.food = this.randomFood();
            }

            randomFood() {
                return {
                    x: Math.floor(Math.random() * this.tileCountX),
                    y: Math.floor(Math.random() * this.tileCountY),
                    color: `hsl(${Math.random()*360},100%,50%)`
                };
            }

            update(deltaTime, timestamp) {
                if(timestamp - this.lastMove < 1000/this.speed) return;
                
                this.direction = this.nextDirection;
                if(this.direction.x === 0 && this.direction.y === 0) return;
                
                const head = {
                    x: this.snake[0].x + this.direction.x,
                    y: this.snake[0].y + this.direction.y
                };
                
                // ç©¿å¢™
                if(head.x < 0) head.x = this.tileCountX - 1;
                if(head.x >= this.tileCountX) head.x = 0;
                if(head.y < 0) head.y = this.tileCountY - 1;
                if(head.y >= this.tileCountY) head.y = 0;
                
                // æ’èº«æ£€æµ‹
                if(this.snake.some(s => s.x === head.x && s.y === head.y)) {
                    this.engine.gameOver();
                    return;
                }
                
                this.snake.unshift(head);
                
                // åƒé£Ÿç‰©
                if(head.x === this.food.x && head.y === this.food.y) {
                    this.engine.addScore(10);
                    this.food = this.randomFood();
                    if(this.snake.length % 5 === 0) {
                        this.speed++;
                        this.engine.setLevel(Math.floor(this.speed - 6));
                    }
                } else {
                    this.snake.pop();
                }
                
                this.lastMove = timestamp;
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // é£Ÿç‰©
                this.ctx.fillStyle = this.food.color;
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = this.food.color;
                this.ctx.beginPath();
                this.ctx.arc(
                    this.food.x * this.gridSize + this.gridSize/2,
                    this.food.y * this.gridSize + this.gridSize/2,
                    this.gridSize/2 - 2, 0, Math.PI*2
                );
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
                
                // è›‡
                this.snake.forEach((segment, i) => {
                    const alpha = 1 - (i / this.snake.length) * 0.5;
                    this.ctx.fillStyle = `rgba(57, 255, 20, ${alpha})`;
                    if(i === 0) {
                        this.ctx.shadowBlur = 20;
                        this.ctx.shadowColor = '#39ff14';
                    }
                    this.ctx.fillRect(
                        segment.x * this.gridSize + 1,
                        segment.y * this.gridSize + 1,
                        this.gridSize - 2, this.gridSize - 2
                    );
                    if(i === 0) {
                        // çœ¼ç›
                        this.ctx.fillStyle = '#000';
                        this.ctx.fillRect(segment.x*this.gridSize+8, segment.y*this.gridSize+8, 4, 4);
                        this.ctx.fillRect(segment.x*this.gridSize+13, segment.y*this.gridSize+8, 4, 4);
                        this.ctx.shadowBlur = 0;
                    }
                });
            }

            handleInput(e) {
                switch(e.key) {
                    case 'ArrowUp': 
                        if(this.direction.y === 0) this.nextDirection = {x: 0, y: -1};
                        break;
                    case 'ArrowDown':
                        if(this.direction.y === 0) this.nextDirection = {x: 0, y: 1};
                        break;
                    case 'ArrowLeft':
                        if(this.direction.x === 0) this.nextDirection = {x: -1, y: 0};
                        break;
                    case 'ArrowRight':
                        if(this.direction.x === 0) this.nextDirection = {x: 1, y: 0};
                        break;
                }
            }

            setupInputs() {
                let touchStartX, touchStartY;
                this.bindEvent(this.canvas, 'touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });
                
                this.bindEvent(this.canvas, 'touchend', (e) => {
                    const dx = e.changedTouches[0].clientX - touchStartX;
                    const dy = e.changedTouches[0].clientY - touchStartY;
                    const absX = Math.abs(dx);
                    const absY = Math.abs(dy);
                    
                    if(absX > absY) {
                        if(dx > 0 && this.direction.x === 0) this.nextDirection = {x: 1, y: 0};
                        else if(dx < 0 && this.direction.x === 0) this.nextDirection = {x: -1, y: 0};
                    } else {
                        if(dy > 0 && this.direction.y === 0) this.nextDirection = {x: 0, y: 1};
                        else if(dy < 0 && this.direction.y === 0) this.nextDirection = {x: 0, y: -1};
                    }
                });
            }
        }

        // ==================== 3. åƒè±†äºº ====================
        class PacmanGame extends BaseGame {
            init() {
                super.init();
                this.tileSize = 30;
                this.cols = Math.floor(this.width / this.tileSize);
                this.rows = Math.floor(this.height / this.tileSize);
                this.initMap();
                this.reset();
            }

            initMap() {
                this.map = [];
                for(let r=0; r<this.rows; r++) {
                    let row = [];
                    for(let c=0; c<this.cols; c++) {
                        if(r===0 || r===this.rows-1 || c===0 || c===this.cols-1 || (r%3===0 && c%4===0))
                            row.push(1); // å¢™
                        else
                            row.push(0); // è±†å­
                    }
                    this.map.push(row);
                }
            }

            reset() {
                this.pacman = {x: 1, y: 1, dx: 0, dy: 0, mouth: 0};
                this.ghosts = [
                    {x: this.cols-2, y: this.rows-2, color: '#ff0000', dx: -1, dy: 0},
                    {x: this.cols-2, y: 1, color: '#ffb8ff', dx: 0, dy: 1}
                ];
                this.dots = 0;
                for(let r=0; r<this.rows; r++)
                    for(let c=0; c<this.cols; c++)
                        if(this.map[r][c] === 0) this.dots++;
            }

            update(deltaTime, timestamp) {
                // ç§»åŠ¨åƒè±†äºº
                if(this.pacman.dx !== 0 || this.pacman.dy !== 0) {
                    const nx = this.pacman.x + this.pacman.dx;
                    const ny = this.pacman.y + this.pacman.dy;
                    if(this.map[ny][nx] !== 1) {
                        this.pacman.x = nx;
                        this.pacman.y = ny;
                        if(this.map[ny][nx] === 0) {
                            this.map[ny][nx] = 2; // åƒæ‰
                            this.engine.addScore(10);
                            this.dots--;
                            if(this.dots <= 0) this.engine.gameOver(true);
                        }
                        this.pacman.mouth += 0.2;
                    }
                }
                
                // ç§»åŠ¨å¹½çµ
                this.ghosts.forEach(ghost => {
                    // ç®€å•è¿½è¸ªAI
                    const dx = this.pacman.x - ghost.x;
                    const dy = this.pacman.y - ghost.y;
                    let moves = [];
                    if(Math.abs(dx) > Math.abs(dy)) {
                        moves.push({x: Math.sign(dx), y: 0});
                        moves.push({x: 0, y: Math.sign(dy)});
                    } else {
                        moves.push({x: 0, y: Math.sign(dy)});
                        moves.push({x: Math.sign(dx), y: 0});
                    }
                    
                    // å°è¯•ç§»åŠ¨
                    let moved = false;
                    for(let move of moves) {
                        const nx = ghost.x + move.x;
                        const ny = ghost.y + move.y;
                        if(this.map[ny][nx] !== 1) {
                            ghost.x = nx;
                            ghost.y = ny;
                            moved = true;
                            break;
                        }
                    }
                    if(!moved) {
                        // éšæœºç§»åŠ¨
                        const dirs = [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}];
                        const dir = dirs[Math.floor(Math.random()*4)];
                        if(this.map[ghost.y+dir.y][ghost.x+dir.x] !== 1) {
                            ghost.x += dir.x;
                            ghost.y += dir.y;
                        }
                    }
                    
                    if(ghost.x === this.pacman.x && ghost.y === this.pacman.y) {
                        this.engine.gameOver();
                    }
                });
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // åœ°å›¾
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        const x = c * this.tileSize;
                        const y = r * this.tileSize;
                        if(this.map[r][c] === 1) {
                            const grad = this.ctx.createLinearGradient(x, y, x+this.tileSize, y+this.tileSize);
                            grad.addColorStop(0, 'rgba(0,150,255,0.8)');
                            grad.addColorStop(1, 'rgba(0,50,150,0.8)');
                            this.ctx.fillStyle = grad;
                            this.ctx.fillRect(x, y, this.tileSize-2, this.tileSize-2);
                        } else if(this.map[r][c] === 0) {
                            this.ctx.fillStyle = '#fff01f';
                            this.ctx.beginPath();
                            this.ctx.arc(x+this.tileSize/2, y+this.tileSize/2, 3, 0, Math.PI*2);
                            this.ctx.fill();
                        }
                    }
                }
                
                // åƒè±†äºº
                this.ctx.fillStyle = '#fff01f';
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = '#fff01f';
                this.ctx.save();
                this.ctx.translate(this.pacman.x*this.tileSize+this.tileSize/2, this.pacman.y*this.tileSize+this.tileSize/2);
                let rotation = 0;
                if(this.pacman.dx === 1) rotation = 0;
                else if(this.pacman.dx === -1) rotation = Math.PI;
                else if(this.pacman.dy === -1) rotation = -Math.PI/2;
                else if(this.pacman.dy === 1) rotation = Math.PI/2;
                this.ctx.rotate(rotation);
                
                this.ctx.beginPath();
                const mouth = Math.abs(Math.sin(this.pacman.mouth)) * 0.2;
                this.ctx.arc(0, 0, this.tileSize/2-2, mouth, Math.PI*2-mouth);
                this.ctx.lineTo(0, 0);
                this.ctx.fill();
                this.ctx.restore();
                
                // å¹½çµ
                this.ghosts.forEach(ghost => {
                    this.ctx.fillStyle = ghost.color;
                    this.ctx.shadowColor = ghost.color;
                    const x = ghost.x * this.tileSize;
                    const y = ghost.y * this.tileSize;
                    this.ctx.beginPath();
                    this.ctx.arc(x+this.tileSize/2, y+this.tileSize/2-5, this.tileSize/2-5, Math.PI, 0);
                    this.ctx.lineTo(x+this.tileSize-5, y+this.tileSize-5);
                    this.ctx.lineTo(x+5, y+this.tileSize-5);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(x+8, y+8, 6, 6);
                    this.ctx.fillRect(x+this.tileSize-14, y+8, 6, 6);
                });
                this.ctx.shadowBlur = 0;
            }

            handleInput(e) {
                switch(e.key) {
                    case 'ArrowUp': this.pacman.dx = 0; this.pacman.dy = -1; break;
                    case 'ArrowDown': this.pacman.dx = 0; this.pacman.dy = 1; break;
                    case 'ArrowLeft': this.pacman.dx = -1; this.pacman.dy = 0; break;
                    case 'ArrowRight': this.pacman.dx = 1; this.pacman.dy = 0; break;
                }
            }

            setupInputs() {
                let startX, startY;
                this.bindEvent(this.canvas, 'touchstart', (e) => {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                });
                
                this.bindEvent(this.canvas, 'touchend', (e) => {
                    const dx = e.changedTouches[0].clientX - startX;
                    const dy = e.changedTouches[0].clientY - startY;
                    if(Math.abs(dx) > Math.abs(dy)) {
                        this.pacman.dx = dx > 0 ? 1 : -1;
                        this.pacman.dy = 0;
                    } else {
                        this.pacman.dx = 0;
                        this.pacman.dy = dy > 0 ? 1 : -1;
                    }
                });
            }
        }

        // ==================== 4. æ‰“ç –å— ====================
        class BreakoutGame extends BaseGame {
            init() {
                super.init();
                this.reset();
            }

            reset() {
                this.paddle = {x: this.width/2-60, y: this.height-40, width: 120, height: 15};
                this.ball = {x: this.width/2, y: this.height/2, dx: 5, dy: -5, radius: 8};
                this.bricks = [];
                const colors = ['#ff2d95','#00f3ff','#39ff14','#fff01f','#b300ff'];
                const rows = 5, cols = 8;
                const brickWidth = (this.width-100)/cols;
                const brickHeight = 25;
                
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        this.bricks.push({
                            x: 50 + c*brickWidth,
                            y: 60 + r*(brickHeight+5),
                            width: brickWidth-5,
                            height: brickHeight,
                            color: colors[r],
                            hit: false
                        });
                    }
                }
            }

            update(deltaTime, timestamp) {
                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;
                
                // å¢™å£ç¢°æ’
                if(this.ball.x + this.ball.radius > this.width || this.ball.x - this.ball.radius < 0)
                    this.ball.dx = -this.ball.dx;
                if(this.ball.y - this.ball.radius < 0)
                    this.ball.dy = -this.ball.dy;
                
                // æŒ¡æ¿ç¢°æ’
                if(this.ball.y + this.ball.radius > this.paddle.y &&
                   this.ball.x > this.paddle.x && 
                   this.ball.x < this.paddle.x + this.paddle.width) {
                    this.ball.dy = -Math.abs(this.ball.dy);
                    const hitPos = (this.ball.x - this.paddle.x) / this.paddle.width;
                    this.ball.dx = 8 * (hitPos - 0.5);
                }
                
                // ç –å—ç¢°æ’
                this.bricks.forEach(brick => {
                    if(!brick.hit &&
                       this.ball.x > brick.x && 
                       this.ball.x < brick.x + brick.width &&
                       this.ball.y > brick.y && 
                       this.ball.y < brick.y + brick.height) {
                        brick.hit = true;
                        this.ball.dy = -this.ball.dy;
                        this.engine.addScore(10);
                    }
                });
                
                if(this.ball.y > this.height) this.engine.gameOver();
                if(this.bricks.every(b => b.hit)) this.engine.gameOver(true);
                
                // é¼ æ ‡è·Ÿéš
                if(this.mouseX !== undefined) {
                    this.paddle.x = this.mouseX - this.paddle.width/2;
                    this.paddle.x = Math.max(0, Math.min(this.width-this.paddle.width, this.paddle.x));
                }
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ç –å—
                this.bricks.forEach(brick => {
                    if(!brick.hit) {
                        this.ctx.fillStyle = brick.color + '40';
                        this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                        this.ctx.strokeStyle = brick.color;
                        this.ctx.lineWidth = 2;
                        this.ctx.shadowBlur = 15;
                        this.ctx.shadowColor = brick.color;
                        this.ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                        this.ctx.shadowBlur = 0;
                    }
                });
                
                // æŒ¡æ¿
                const grad = this.ctx.createLinearGradient(this.paddle.x, this.paddle.y, this.paddle.x, this.paddle.y+this.paddle.height);
                grad.addColorStop(0, 'rgba(0,243,255,0.8)');
                grad.addColorStop(1, 'rgba(0,100,255,0.8)');
                this.ctx.fillStyle = grad;
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = '#00f3ff';
                this.ctx.beginPath();
                this.ctx.roundRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height, 8);
                this.ctx.fill();
                
                // çƒ
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI*2);
                this.ctx.fillStyle = '#fff';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }

            setupInputs() {
                this.bindEvent(this.canvas, 'mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                });
                
                this.bindEvent(this.canvas, 'touchmove', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.touches[0].clientX - rect.left;
                });
            }
        }

        // ==================== 5. å¤ªç©ºå°„å‡» ====================
        class ShooterGame extends BaseGame {
            init() {
                super.init();
                this.reset();
                this.stars = Array(100).fill().map(() => ({
                    x: Math.random()*this.width,
                    y: Math.random()*this.height,
                    speed: Math.random()*3+1
                }));
            }

            reset() {
                this.player = {x: this.width/2, y: this.height-100, bullets: []};
                this.enemies = [];
                this.lastShot = 0;
            }

            update(deltaTime, timestamp) {
                // æ˜Ÿæ˜ŸèƒŒæ™¯
                this.stars.forEach(star => {
                    star.y += star.speed;
                    if(star.y > this.height) star.y = 0;
                });
                
                // ç©å®¶ç§»åŠ¨
                if(this.keys && this.keys['ArrowLeft']) this.player.x = Math.max(20, this.player.x-8);
                if(this.keys && this.keys['ArrowRight']) this.player.x = Math.min(this.width-20, this.player.x+8);
                
                // å‘å°„å­å¼¹
                if(this.keys && this.keys[' '] && timestamp - this.lastShot > 200) {
                    this.player.bullets.push({x: this.player.x, y: this.player.y-30});
                    this.lastShot = timestamp;
                }
                
                // æ›´æ–°å­å¼¹
                this.player.bullets = this.player.bullets.filter(b => {
                    b.y -= 10;
                    return b.y > 0;
                });
                
                // ç”Ÿæˆæ•Œäºº
                if(Math.random() < 0.02 + this.engine.level*0.005) {
                    this.enemies.push({
                        x: Math.random()*(this.width-40)+20,
                        y: -30,
                        hp: 2+Math.floor(this.engine.level/3)
                    });
                }
                
                // æ›´æ–°æ•Œäºº
                this.enemies = this.enemies.filter(e => {
                    e.y += 2 + this.engine.level*0.5;
                    
                    // ç¢°æ’æ£€æµ‹
                    for(let i=this.player.bullets.length-1; i>=0; i--) {
                        const b = this.player.bullets[i];
                        if(Math.hypot(b.x-e.x, b.y-e.y) < 20) {
                            e.hp--;
                            this.player.bullets.splice(i, 1);
                            if(e.hp <= 0) {
                                this.engine.addScore(20);
                                return false;
                            }
                        }
                    }
                    
                    if(Math.hypot(e.x-this.player.x, e.y-this.player.y) < 30) {
                        this.engine.gameOver();
                    }
                    
                    return e.y < this.height;
                });
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // æ˜Ÿæ˜Ÿ
                this.ctx.fillStyle = '#fff';
                this.stars.forEach(star => {
                    this.ctx.globalAlpha = Math.random()*0.5+0.5;
                    this.ctx.fillRect(star.x, star.y, 2, 2);
                });
                this.ctx.globalAlpha = 1;
                
                // ç©å®¶é£èˆ¹
                this.ctx.save();
                this.ctx.translate(this.player.x, this.player.y);
                this.ctx.shadowBlur = 30;
                this.ctx.shadowColor = '#00f3ff';
                const grad = this.ctx.createLinearGradient(0, -20, 0, 20);
                grad.addColorStop(0, '#00f3ff');
                grad.addColorStop(1, '#0066cc');
                this.ctx.fillStyle = grad;
                this.ctx.beginPath();
                this.ctx.moveTo(0, -30);
                this.ctx.lineTo(-15, 20);
                this.ctx.lineTo(0, 10);
                this.ctx.lineTo(15, 20);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.restore();
                
                // å­å¼¹
                this.ctx.fillStyle = '#ffea00';
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = '#ffea00';
                this.player.bullets.forEach(b => {
                    this.ctx.fillRect(b.x-2, b.y-10, 4, 20);
                });
                
                // æ•Œäºº
                this.enemies.forEach(e => {
                    const grad = this.ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, 15);
                    grad.addColorStop(0, '#ff2d95');
                    grad.addColorStop(1, '#990000');
                    this.ctx.fillStyle = grad;
                    this.ctx.beginPath();
                    this.ctx.arc(e.x, e.y, 15, 0, Math.PI*2);
                    this.ctx.fill();
                });
                this.ctx.shadowBlur = 0;
            }

            handleInput(e) {
                if(!this.keys) this.keys = {};
                if(e.type === 'keydown') this.keys[e.key] = true;
                if(e.type === 'keyup') this.keys[e.key] = false;
            }

            setupInputs() {
                window.addEventListener('keydown', (e) => this.handleInput(e));
                window.addEventListener('keyup', (e) => this.handleInput(e));
                this.bindings.push({element: window, event: 'keydown', handler: (e) => this.handleInput(e)});
                this.bindings.push({element: window, event: 'keyup', handler: (e) => this.handleInput(e)});
                
                this.bindEvent(this.canvas, 'touchmove', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.x = e.touches[0].clientX - rect.left;
                });
                
                this.bindEvent(this.canvas, 'touchstart', (e) => {
                    this.player.bullets.push({x: this.player.x, y: this.player.y-30});
                });
            }
        }

        // ==================== 6. å¼¹çƒå° ====================
        class PinballGame extends BaseGame {
            init() {
                super.init();
                this.reset();
            }

            reset() {
                this.ball = {x: this.width/2, y: this.height-150, dx: 4, dy: -4, radius: 10};
                this.paddles = [
                    {x: 80, y: this.height-80, width: 80, height: 15, angle: 0.3, key: 'z'},
                    {x: this.width-160, y: this.height-80, width: 80, height: 15, angle: -0.3, key: 'm'}
                ];
                this.bumpers = [
                    {x: this.width/3, y: this.height/3, radius: 30},
                    {x: this.width*2/3, y: this.height/3, radius: 30},
                    {x: this.width/2, y: this.height/2, radius: 25}
                ];
            }

            update(deltaTime, timestamp) {
                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;
                
                // å¢™å£
                if(this.ball.x + this.ball.radius > this.width || this.ball.x - this.ball.radius < 0)
                    this.ball.dx *= -1;
                if(this.ball.y - this.ball.radius < 0)
                    this.ball.dy *= -1;
                if(this.ball.y > this.height) {
                    this.engine.gameOver();
                    return;
                }
                
                // æŒ¡æ¿ç¢°æ’
                this.paddles.forEach(paddle => {
                    const cos = Math.cos(paddle.angle);
                    const sin = Math.sin(paddle.angle);
                    
                    // ç®€åŒ–çš„æŒ¡æ¿ç¢°æ’æ£€æµ‹
                    if(this.ball.y + this.ball.radius > paddle.y - 10 && 
                       this.ball.y - this.ball.radius < paddle.y + 10 &&
                       this.ball.x > paddle.x && 
                       this.ball.x < paddle.x + paddle.width) {
                        this.ball.dy = -Math.abs(this.ball.dy);
                        this.ball.dx += (this.ball.x - (paddle.x + paddle.width/2)) * 0.1;
                        this.engine.addScore(5);
                    }
                });
                
                // ç¼“å†²å™¨ç¢°æ’
                this.bumpers.forEach(bumper => {
                    const dist = Math.hypot(this.ball.x - bumper.x, this.ball.y - bumper.y);
                    if(dist < this.ball.radius + bumper.radius) {
                        const angle = Math.atan2(this.ball.y - bumper.y, this.ball.x - bumper.x);
                        this.ball.dx = Math.cos(angle) * 6;
                        this.ball.dy = Math.sin(angle) * 6;
                        this.engine.addScore(50);
                    }
                });
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ç¼“å†²å™¨
                this.bumpers.forEach(bumper => {
                    const grad = this.ctx.createRadialGradient(bumper.x-5, bumper.y-5, 0, bumper.x, bumper.y, bumper.radius);
                    grad.addColorStop(0, '#fff');
                    grad.addColorStop(0.5, '#00f3ff');
                    grad.addColorStop(1, '#0066cc');
                    this.ctx.fillStyle = grad;
                    this.ctx.shadowBlur = 30;
                    this.ctx.shadowColor = '#00f3ff';
                    this.ctx.beginPath();
                    this.ctx.arc(bumper.x, bumper.y, bumper.radius, 0, Math.PI*2);
                    this.ctx.fill();
                });
                
                // æŒ¡æ¿
                this.paddles.forEach(paddle => {
                    this.ctx.save();
                    this.ctx.translate(paddle.x + paddle.width/2, paddle.y);
                    this.ctx.rotate(paddle.angle);
                    this.ctx.fillStyle = '#ff2d95';
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = '#ff2d95';
                    this.ctx.fillRect(-paddle.width/2, -paddle.height/2, paddle.width, paddle.height);
                    this.ctx.restore();
                });
                
                // çƒ
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI*2);
                this.ctx.fillStyle = '#fff01f';
                this.ctx.shadowColor = '#fff01f';
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }

            handleInput(e) {
                this.paddles.forEach(paddle => {
                    if(e.key === paddle.key) {
                        if(e.type === 'keydown') paddle.angle = -paddle.angle;
                        if(e.type === 'keyup') paddle.angle = -paddle.angle;
                    }
                });
            }

            setupInputs() {
                window.addEventListener('keydown', (e) => this.handleInput(e));
                window.addEventListener('keyup', (e) => this.handleInput(e));
                this.bindings.push({element: window, event: 'keydown', handler: (e) => this.handleInput(e)});
                this.bindings.push({element: window, event: 'keyup', handler: (e) => this.handleInput(e)});
            }
        }

        // ==================== 7. èµ›è½¦æ¸¸æˆ ====================
        class RacingGame extends BaseGame {
            init() {
                super.init();
                this.reset();
                this.roadOffset = 0;
            }

            reset() {
                this.player = {x: this.width/2, y: this.height-100, width: 50, height: 80};
                this.enemies = [];
                this.speed = 5;
            }

            update(deltaTime, timestamp) {
                this.roadOffset = (this.roadOffset + this.speed) % 80;
                
                // ç”Ÿæˆè½¦è¾†
                if(Math.random() < 0.02 * this.engine.level) {
                    const lane = Math.floor(Math.random() * 3);
                    const laneWidth = this.width / 3;
                    this.enemies.push({
                        x: lane * laneWidth + laneWidth/2,
                        y: -100,
                        width: 50,
                        height: 80,
                        color: `hsl(${Math.random()*360},100%,50%)`
                    });
                }
                
                // æ›´æ–°è½¦è¾†
                this.enemies = this.enemies.filter(e => {
                    e.y += this.speed + 2;
                    
                    // ç¢°æ’æ£€æµ‹
                    if(Math.abs(this.player.x - e.x) < (this.player.width + e.width)/2 &&
                       Math.abs(this.player.y - e.y) < (this.player.height + e.height)/2) {
                        this.engine.gameOver();
                    }
                    
                    if(e.y > this.height) {
                        this.engine.addScore(10);
                        return false;
                    }
                    return true;
                });
                
                // é”®ç›˜æ§åˆ¶
                if(this.keys) {
                    if(this.keys['ArrowLeft']) this.player.x -= 8;
                    if(this.keys['ArrowRight']) this.player.x += 8;
                }
                this.player.x = Math.max(25, Math.min(this.width-25, this.player.x));
            }

            render() {
                // é“è·¯
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // è½¦é“çº¿
                this.ctx.fillStyle = '#fff';
                for(let i=0; i<this.height; i+=80) {
                    this.ctx.fillRect(this.width/3 - 2, i + this.roadOffset, 4, 40);
                    this.ctx.fillRect(this.width*2/3 - 2, i + this.roadOffset, 4, 40);
                }
                
                // ç©å®¶è½¦
                this.ctx.fillStyle = '#00f3ff';
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = '#00f3ff';
                this.ctx.fillRect(this.player.x - this.player.width/2, this.player.y - this.player.height/2, this.player.width, this.player.height);
                // è½¦çª—
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(this.player.x - 15, this.player.y - 20, 30, 25);
                
                // æ•Œè½¦
                this.enemies.forEach(e => {
                    this.ctx.fillStyle = e.color;
                    this.ctx.shadowColor = e.color;
                    this.ctx.fillRect(e.x - e.width/2, e.y - e.height/2, e.width, e.height);
                });
                this.ctx.shadowBlur = 0;
            }

            handleInput(e) {
                if(!this.keys) this.keys = {};
                if(e.type === 'keydown') this.keys[e.key] = true;
                if(e.type === 'keyup') this.keys[e.key] = false;
            }

            setupInputs() {
                window.addEventListener('keydown', (e) => this.handleInput(e));
                window.addEventListener('keyup', (e) => this.handleInput(e));
                this.bindings.push({element: window, event: 'keydown', handler: (e) => this.handleInput(e)});
                this.bindings.push({element: window, event: 'keyup', handler: (e) => this.handleInput(e)});
                
                this.bindEvent(this.canvas, 'touchmove', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    this.player.x = e.touches[0].clientX - rect.left;
                });
            }
        }

        // ==================== 8. Flappy Bird ====================
        class FlappyGame extends BaseGame {
            init() {
                super.init();
                this.reset();
            }

            reset() {
                this.bird = {x: 50, y: this.height/2, velocity: 0, radius: 15};
                this.pipes = [];
                this.frame = 0;
            }

            jump() {
                this.bird.velocity = -8;
            }

            update(deltaTime, timestamp) {
                if(this.frame % 100 === 0) {
                    const gap = 120;
                    const topHeight = Math.random() * (this.height - gap - 200) + 50;
                    this.pipes.push({
                        x: this.width,
                        topHeight: topHeight,
                        gap: gap,
                        passed: false
                    });
                }
                
                this.pipes = this.pipes.filter(pipe => {
                    pipe.x -= 3;
                    
                    // ç¢°æ’æ£€æµ‹
                    if(this.bird.x + this.bird.radius > pipe.x && 
                       this.bird.x - this.bird.radius < pipe.x + 60) {
                        if(this.bird.y - this.bird.radius < pipe.topHeight ||
                           this.bird.y + this.bird.radius > pipe.topHeight + pipe.gap) {
                            this.engine.gameOver();
                        }
                    }
                    
                    // è®¡åˆ†
                    if(!pipe.passed && pipe.x + 60 < this.bird.x) {
                        this.engine.addScore(10);
                        pipe.passed = true;
                    }
                    
                    return pipe.x > -60;
                });
                
                this.bird.velocity += 0.5;
                this.bird.y += this.bird.velocity;
                
                if(this.bird.y > this.height || this.bird.y < 0) this.engine.gameOver();
                this.frame++;
            }

            render() {
                this.ctx.fillStyle = 'rgba(135,206,235,0.3)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ç®¡é“
                this.ctx.fillStyle = '#39ff14';
                this.pipes.forEach(pipe => {
                    this.ctx.fillRect(pipe.x, 0, 60, pipe.topHeight);
                    this.ctx.fillRect(pipe.x, pipe.topHeight + pipe.gap, 60, this.height);
                });
                
                // é¸Ÿ
                this.ctx.fillStyle = '#fff01f';
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = '#fff01f';
                this.ctx.beginPath();
                this.ctx.arc(this.bird.x, this.bird.y, this.bird.radius, 0, Math.PI*2);
                this.ctx.fill();
                // çœ¼ç›
                this.ctx.fillStyle = '#fff';
                this.ctx.fillRect(this.bird.x+5, this.bird.y-5, 6, 6);
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(this.bird.x+8, this.bird.y-3, 2, 2);
                this.ctx.shadowBlur = 0;
            }

            setupInputs() {
                this.bindEvent(this.canvas, 'mousedown', () => this.jump());
                this.bindEvent(this.canvas, 'touchstart', (e) => {
                    e.preventDefault();
                    this.jump();
                });
                this.bindEvent(window, 'keydown', (e) => {
                    if(e.key === ' ') this.jump();
                });
            }
        }

        // ==================== 9. 2048 ====================
        class Game2048 extends BaseGame {
            init() {
                super.init();
                this.gridSize = 4;
                this.tileSize = Math.min(this.width, this.height-100) / this.gridSize - 10;
                this.offsetX = (this.width - this.gridSize*(this.tileSize+10))/2;
                this.offsetY = 50;
                this.reset();
            }

            reset() {
                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
                this.addRandom();
                this.addRandom();
            }

            addRandom() {
                let empty = [];
                for(let r=0; r<this.gridSize; r++) {
                    for(let c=0; c<this.gridSize; c++) {
                        if(this.grid[r][c] === 0) empty.push({r,c});
                    }
                }
                if(empty.length > 0) {
                    const {r,c} = empty[Math.floor(Math.random()*empty.length)];
                    this.grid[r][c] = Math.random() < 0.9 ? 2 : 4;
                }
            }

            move(direction) {
                let moved = false;
                const newGrid = this.grid.map(row => [...row]);
                
                for(let i=0; i<this.gridSize; i++) {
                    let line = [];
                    for(let j=0; j<this.gridSize; j++) {
                        const r = direction==='up' ? j : direction==='down' ? this.gridSize-1-j : i;
                        const c = direction==='left' ? j : direction==='right' ? this.gridSize-1-j : i;
                        line.push(this.grid[r][c]);
                    }
                    
                    line = line.filter(x => x!==0);
                    for(let j=0; j<line.length-1; j++) {
                        if(line[j] === line[j+1]) {
                            line[j] *= 2;
                            this.engine.addScore(line[j]);
                            line[j+1] = 0;
                        }
                    }
                    line = line.filter(x => x!==0);
                    while(line.length < this.gridSize) line.push(0);
                    
                    for(let j=0; j<this.gridSize; j++) {
                        const r = direction==='up' ? j : direction==='down' ? this.gridSize-1-j : i;
                        const c = direction==='left' ? j : direction==='right' ? this.gridSize-1-j : i;
                        if(newGrid[r][c] !== line[j]) moved = true;
                        newGrid[r][c] = line[j];
                    }
                }
                
                if(moved) {
                    this.grid = newGrid;
                    this.addRandom();
                    if(this.checkWin()) this.engine.gameOver(true);
                    else if(!this.canMove()) this.engine.gameOver();
                }
            }

            checkWin() {
                return this.grid.some(row => row.includes(2048));
            }

            canMove() {
                for(let r=0; r<this.gridSize; r++) {
                    for(let c=0; c<this.gridSize; c++) {
                        if(this.grid[r][c] === 0) return true;
                        if(c<this.gridSize-1 && this.grid[r][c]===this.grid[r][c+1]) return true;
                        if(r<this.gridSize-1 && this.grid[r][c]===this.grid[r+1][c]) return true;
                    }
                }
                return false;
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                for(let r=0; r<this.gridSize; r++) {
                    for(let c=0; c<this.gridSize; c++) {
                        this.drawTile(r, c, this.grid[r][c]);
                    }
                }
            }

            drawTile(r, c, value) {
                const x = this.offsetX + c*(this.tileSize+10);
                const y = this.offsetY + r*(this.tileSize+10);
                const colors = {
                    0: 'rgba(255,255,255,0.05)',
                    2: '#eee4da', 4: '#ede0c8', 8: '#f2b179',
                    16: '#f59563', 32: '#f67c5f', 64: '#f65e3b',
                    128: '#edcf72', 256: '#edcc61', 512: '#edc850',
                    1024: '#edc53f', 2048: '#edc22e'
                };
                
                this.ctx.fillStyle = colors[value] || '#3c3a32';
                this.ctx.fillRect(x, y, this.tileSize, this.tileSize);
                
                if(value > 0) {
                    this.ctx.fillStyle = value <= 4 ? '#776e65' : '#f9f6f2';
                    this.ctx.font = `bold ${this.tileSize/2.5}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(value, x+this.tileSize/2, y+this.tileSize/2);
                }
            }

            update() {} // é™æ€æ¸¸æˆï¼Œä¸éœ€è¦update

            handleInput(e) {
                switch(e.key) {
                    case 'ArrowUp': this.move('up'); break;
                    case 'ArrowDown': this.move('down'); break;
                    case 'ArrowLeft': this.move('left'); break;
                    case 'ArrowRight': this.move('right'); break;
                }
            }

            setupInputs() {
                let startX, startY;
                this.bindEvent(this.canvas, 'touchstart', (e) => {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                });
                
                this.bindEvent(this.canvas, 'touchend', (e) => {
                    const dx = e.changedTouches[0].clientX - startX;
                    const dy = e.changedTouches[0].clientY - startY;
                    if(Math.abs(dx) > Math.abs(dy)) {
                        this.move(dx > 0 ? 'right' : 'left');
                    } else {
                        this.move(dy > 0 ? 'down' : 'up');
                    }
                });
            }
        }

        // ==================== 10. æ‰«é›· ====================
        class MinesweeperGame extends BaseGame {
            init() {
                super.init();
                this.cols = 10;
                this.rows = 10;
                this.mines = 15;
                this.cellSize = Math.min(this.width/this.cols, this.height/this.rows) * 0.9;
                this.offsetX = (this.width - this.cols*this.cellSize)/2;
                this.offsetY = (this.height - this.rows*this.cellSize)/2;
                this.reset();
            }

            reset() {
                this.board = Array(this.rows).fill().map(() => 
                    Array(this.cols).fill().map(() => ({
                        mine: false, revealed: false, flagged: false, count: 0
                    }))
                );
                
                // æ”¾ç½®åœ°é›·
                let placed = 0;
                while(placed < this.mines) {
                    const r = Math.floor(Math.random()*this.rows);
                    const c = Math.floor(Math.random()*this.cols);
                    if(!this.board[r][c].mine) {
                        this.board[r][c].mine = true;
                        placed++;
                    }
                }
                
                // è®¡ç®—æ•°å­—
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        if(!this.board[r][c].mine) {
                            let count = 0;
                            for(let dr=-1; dr<=1; dr++) {
                                for(let dc=-1; dc<=1; dc++) {
                                    const nr=r+dr, nc=c+dc;
                                    if(nr>=0 && nr<this.rows && nc>=0 && nc<this.cols && this.board[nr][nc].mine)
                                        count++;
                                }
                            }
                            this.board[r][c].count = count;
                        }
                    }
                }
            }

            reveal(r, c) {
                if(r<0 || r>=this.rows || c<0 || c>=this.cols) return;
                const cell = this.board[r][c];
                if(cell.revealed || cell.flagged) return;
                
                cell.revealed = true;
                if(cell.mine) {
                    this.engine.gameOver();
                    return;
                }
                
                if(cell.count === 0) {
                    for(let dr=-1; dr<=1; dr++) {
                        for(let dc=-1; dc<=1; dc++) {
                            this.reveal(r+dr, c+dc);
                        }
                    }
                }
                this.checkWin();
            }

            checkWin() {
                let revealed = 0;
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        if(this.board[r][c].revealed) revealed++;
                    }
                }
                if(revealed === this.rows*this.cols - this.mines) {
                    this.engine.addScore(1000);
                    this.engine.gameOver(true);
                }
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        const x = this.offsetX + c*this.cellSize;
                        const y = this.offsetY + r*this.cellSize;
                        const cell = this.board[r][c];
                        
                        if(!cell.revealed) {
                            this.ctx.fillStyle = cell.flagged ? '#ff2d95' : 'rgba(0,243,255,0.3)';
                            this.ctx.fillRect(x+1, y+1, this.cellSize-2, this.cellSize-2);
                            if(cell.flagged) {
                                this.ctx.fillStyle = '#fff';
                                this.ctx.font = `${this.cellSize*0.6}px Arial`;
                                this.ctx.textAlign = 'center';
                                this.ctx.fillText('ğŸš©', x+this.cellSize/2, y+this.cellSize*0.75);
                            }
                        } else {
                            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                            this.ctx.fillRect(x+1, y+1, this.cellSize-2, this.cellSize-2);
                            if(cell.mine) {
                                this.ctx.fillStyle = '#ff0000';
                                this.ctx.beginPath();
                                this.ctx.arc(x+this.cellSize/2, y+this.cellSize/2, this.cellSize/3, 0, Math.PI*2);
                                this.ctx.fill();
                            } else if(cell.count > 0) {
                                const colors = ['','#00f3ff','#39ff14','#ff2d95','#b300ff'];
                                this.ctx.fillStyle = colors[cell.count] || '#fff';
                                this.ctx.font = `bold ${this.cellSize*0.6}px Arial`;
                                this.ctx.textAlign = 'center';
                                this.ctx.fillText(cell.count, x+this.cellSize/2, y+this.cellSize*0.75);
                            }
                        }
                    }
                }
            }

            setupInputs() {
                this.bindEvent(this.canvas, 'click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const c = Math.floor((x-this.offsetX)/this.cellSize);
                    const r = Math.floor((y-this.offsetY)/this.cellSize);
                    if(r>=0 && r<this.rows && c>=0 && c<this.cols) {
                        this.reveal(r, c);
                    }
                });
                
                this.bindEvent(this.canvas, 'contextmenu', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const c = Math.floor((x-this.offsetX)/this.cellSize);
                    const r = Math.floor((y-this.offsetY)/this.cellSize);
                    if(r>=0 && r<this.rows && c>=0 && c<this.cols && !this.board[r][c].revealed) {
                        this.board[r][c].flagged = !this.board[r][c].flagged;
                    }
                });
            }
        }

        // ==================== 11. äº•å­—æ£‹ ====================
        class TicTacToeGame extends BaseGame {
            init() {
                super.init();
                this.size = 3;
                this.cellSize = Math.min(this.width, this.height-100)/this.size * 0.8;
                this.offsetX = (this.width - this.size*this.cellSize)/2;
                this.offsetY = 50;
                this.reset();
            }

            reset() {
                this.board = Array(this.size).fill().map(() => Array(this.size).fill(''));
                this.currentPlayer = 'X';
                this.gameOver = false;
            }

            checkWinner() {
                for(let i=0; i<this.size; i++) {
                    if(this.board[i][0] && this.board[i][0]===this.board[i][1] && this.board[i][1]===this.board[i][2])
                        return this.board[i][0];
                    if(this.board[0][i] && this.board[0][i]===this.board[1][i] && this.board[1][i]===this.board[2][i])
                        return this.board[0][i];
                }
                if(this.board[0][0] && this.board[0][0]===this.board[1][1] && this.board[1][1]===this.board[2][2])
                    return this.board[0][0];
                if(this.board[0][2] && this.board[0][2]===this.board[1][1] && this.board[1][1]===this.board[2][0])
                    return this.board[0][2];
                if(this.board.every(row => row.every(cell => cell!==''))) return 'draw';
                return null;
            }

            aiMove() {
                if(this.gameOver) return;
                // ç®€å•AIï¼šä¼˜å…ˆè·èƒœï¼Œå…¶æ¬¡é˜»æŒ¡ï¼Œå¦åˆ™éšæœº
                for(let r=0; r<this.size; r++) {
                    for(let c=0; c<this.size; c++) {
                        if(this.board[r][c]==='') {
                            this.board[r][c]='O';
                            if(this.checkWinner()==='O') return;
                            this.board[r][c]='';
                        }
                    }
                }
                for(let r=0; r<this.size; r++) {
                    for(let c=0; c<this.size; c++) {
                        if(this.board[r][c]==='') {
                            this.board[r][c]='X';
                            if(this.checkWinner()==='X') {
                                this.board[r][c]='O';
                                return;
                            }
                            this.board[r][c]='';
                        }
                    }
                }
                let empty = [];
                for(let r=0; r<this.size; r++) {
                    for(let c=0; c<this.size; c++) {
                        if(this.board[r][c]==='') empty.push({r,c});
                    }
                }
                if(empty.length > 0) {
                    const move = empty[Math.floor(Math.random()*empty.length)];
                    this.board[move.r][move.c] = 'O';
                }
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ç½‘æ ¼
                this.ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                this.ctx.lineWidth = 5;
                for(let i=1; i<this.size; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.offsetX+i*this.cellSize, this.offsetY);
                    this.ctx.lineTo(this.offsetX+i*this.cellSize, this.offsetY+this.size*this.cellSize);
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.offsetX, this.offsetY+i*this.cellSize);
                    this.ctx.lineTo(this.offsetX+this.size*this.cellSize, this.offsetY+i*this.cellSize);
                    this.ctx.stroke();
                }
                
                // æ ‡è®°
                for(let r=0; r<this.size; r++) {
                    for(let c=0; c<this.size; c++) {
                        const x = this.offsetX+c*this.cellSize+this.cellSize/2;
                        const y = this.offsetY+r*this.cellSize+this.cellSize/2;
                        
                        if(this.board[r][c]==='X') {
                            this.ctx.strokeStyle = '#00f3ff';
                            this.ctx.lineWidth = 8;
                            this.ctx.shadowBlur = 20;
                            this.ctx.shadowColor = '#00f3ff';
                            this.ctx.beginPath();
                            this.ctx.moveTo(x-20, y-20);
                            this.ctx.lineTo(x+20, y+20);
                            this.ctx.moveTo(x+20, y-20);
                            this.ctx.lineTo(x-20, y+20);
                            this.ctx.stroke();
                        } else if(this.board[r][c]==='O') {
                            this.ctx.strokeStyle = '#ff2d95';
                            this.ctx.lineWidth = 8;
                            this.ctx.shadowBlur = 20;
                            this.ctx.shadowColor = '#ff2d95';
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 25, 0, Math.PI*2);
                            this.ctx.stroke();
                        }
                    }
                }
                this.ctx.shadowBlur = 0;
            }

            setupInputs() {
                this.bindEvent(this.canvas, 'click', (e) => {
                    if(this.gameOver || this.currentPlayer !== 'X') return;
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const c = Math.floor((x-this.offsetX)/this.cellSize);
                    const r = Math.floor((y-this.offsetY)/this.cellSize);
                    
                    if(r>=0 && r<this.size && c>=0 && c<this.size && this.board[r][c]==='') {
                        this.board[r][c] = 'X';
                        const winner = this.checkWinner();
                        if(winner) {
                            this.gameOver = true;
                            if(winner === 'X') this.engine.addScore(100);
                            setTimeout(() => alert(winner==='draw'?'å¹³å±€!':(winner==='X'?'ä½ èµ¢äº†!':'ç”µè„‘èµ¢äº†!')), 100);
                        } else {
                            setTimeout(() => {
                                this.aiMove();
                                const winner2 = this.checkWinner();
                                if(winner2) {
                                    this.gameOver = true;
                                    if(winner2 === 'X') this.engine.addScore(100);
                                    setTimeout(() => alert('ç”µè„‘èµ¢äº†!'), 100);
                                }
                            }, 500);
                        }
                    }
                });
            }
        }

        // ==================== 12. è®°å¿†ç¿»ç‰Œ ====================
        class MemoryGame extends BaseGame {
            init() {
                super.init();
                this.cols = 4;
                this.rows = 4;
                this.cards = [];
                const symbols = ['ğŸ®','ğŸ¯','ğŸ²','ğŸ¸','ğŸš€','ğŸ’','ğŸ”¥','âš¡'];
                const deck = [...symbols, ...symbols].sort(() => Math.random()-0.5);
                const cardWidth = (this.width-100)/this.cols;
                const cardHeight = (this.height-100)/this.rows;
                
                for(let i=0; i<this.cols*this.rows; i++) {
                    this.cards.push({
                        x: 50+(i%this.cols)*cardWidth,
                        y: 50+Math.floor(i/this.cols)*cardHeight,
                        symbol: deck[i],
                        flipped: false,
                        matched: false
                    });
                }
                this.flipped = [];
                this.canFlip = true;
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const cardWidth = (this.width-100)/this.cols;
                const cardHeight = (this.height-100)/this.rows;
                
                this.cards.forEach(card => {
                    this.ctx.save();
                    this.ctx.translate(card.x+cardWidth/2, card.y+cardHeight/2);
                    
                    if(card.flipped || card.matched) {
                        const grad = this.ctx.createLinearGradient(-cardWidth/2, -cardHeight/2, cardWidth/2, cardHeight/2);
                        grad.addColorStop(0, card.matched?'rgba(57,255,20,0.8)':'rgba(255,255,255,0.9)');
                        grad.addColorStop(1, card.matched?'rgba(57,255,20,0.4)':'rgba(255,255,255,0.6)');
                        this.ctx.fillStyle = grad;
                    } else {
                        const grad = this.ctx.createLinearGradient(-cardWidth/2, -cardHeight/2, cardWidth/2, cardHeight/2);
                        grad.addColorStop(0, 'rgba(0,243,255,0.6)');
                        grad.addColorStop(1, 'rgba(179,0,255,0.6)');
                        this.ctx.fillStyle = grad;
                    }
                    
                    this.ctx.beginPath();
                    this.ctx.roundRect(-cardWidth/2+5, -cardHeight/2+5, cardWidth-10, cardHeight-10, 15);
                    this.ctx.fill();
                    
                    if(card.flipped || card.matched) {
                        this.ctx.fillStyle = '#000';
                        this.ctx.font = `${cardHeight/2}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(card.symbol, 0, 0);
                    }
                    this.ctx.restore();
                });
            }

            update() {} // é™æ€æ¸¸æˆ

            setupInputs() {
                const cardWidth = (this.width-100)/this.cols;
                const cardHeight = (this.height-100)/this.rows;
                
                this.bindEvent(this.canvas, 'click', (e) => {
                    if(!this.canFlip) return;
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    this.cards.forEach(card => {
                        if(x>=card.x && x<=card.x+cardWidth && y>=card.y && y<=card.y+cardHeight &&
                           !card.flipped && !card.matched) {
                            card.flipped = true;
                            this.flipped.push(card);
                            
                            if(this.flipped.length === 2) {
                                this.canFlip = false;
                                if(this.flipped[0].symbol === this.flipped[1].symbol) {
                                    this.flipped[0].matched = true;
                                    this.flipped[1].matched = true;
                                    this.engine.addScore(50);
                                    this.flipped = [];
                                    this.canFlip = true;
                                    if(this.cards.every(c => c.matched)) {
                                        setTimeout(() => this.engine.gameOver(true), 500);
                                    }
                                } else {
                                    setTimeout(() => {
                                        this.flipped[0].flipped = false;
                                        this.flipped[1].flipped = false;
                                        this.flipped = [];
                                        this.canFlip = true;
                                    }, 1000);
                                }
                            }
                        }
                    });
                });
            }
        }

        // ==================== 13. æ‰“åœ°é¼  ====================
        class WhackAMoleGame extends BaseGame {
            init() {
                super.init();
                this.cols = 3;
                this.rows = 3;
                this.moles = Array(this.rows).fill().map(() => Array(this.cols).fill(null));
                this.lastSpawn = 0;
                this.timeLeft = 30;
                this.timer = setInterval(() => {
                    if(!this.engine.isPaused) {
                        this.timeLeft--;
                        if(this.timeLeft <= 0) this.engine.gameOver();
                    }
                }, 1000);
            }

            destroy() {
                super.destroy();
                clearInterval(this.timer);
            }

            update(deltaTime, timestamp) {
                if(timestamp - this.lastSpawn > 1000 - this.engine.level*100) {
                    const r = Math.floor(Math.random()*this.rows);
                    const c = Math.floor(Math.random()*this.cols);
                    if(!this.moles[r][c]) {
                        this.moles[r][c] = {time: Date.now()};
                        this.lastSpawn = timestamp;
                    }
                }
                
                // æ£€æŸ¥è¿‡æœŸ
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        if(this.moles[r][c] && Date.now() - this.moles[r][c].time > 1500) {
                            this.moles[r][c] = null;
                        }
                    }
                }
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const cellWidth = this.width/this.cols;
                const cellHeight = (this.height-50)/this.rows;
                
                // æ—¶é—´
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '20px Arial';
                this.ctx.fillText(`æ—¶é—´: ${this.timeLeft}`, 20, 30);
                
                for(let r=0; r<this.rows; r++) {
                    for(let c=0; c<this.cols; c++) {
                        const x = c*cellWidth;
                        const y = 50+r*cellHeight;
                        
                        // æ´
                        this.ctx.fillStyle = '#333';
                        this.ctx.beginPath();
                        this.ctx.ellipse(x+cellWidth/2, y+cellHeight/2+20, cellWidth/3, 15, 0, 0, Math.PI*2);
                        this.ctx.fill();
                        
                        // åœ°é¼ 
                        if(this.moles[r][c]) {
                            const grad = this.ctx.createRadialGradient(x+cellWidth/2, y+cellHeight/2-10, 0, x+cellWidth/2, y+cellHeight/2, cellWidth/3);
                            grad.addColorStop(0, '#8B4513');
                            grad.addColorStop(1, '#3d2817');
                            this.ctx.fillStyle = grad;
                            this.ctx.beginPath();
                            this.ctx.arc(x+cellWidth/2, y+cellHeight/2, cellWidth/3, 0, Math.PI*2);
                            this.ctx.fill();
                            
                            this.ctx.fillStyle = '#fff';
                            this.ctx.beginPath();
                            this.ctx.arc(x+cellWidth/2-10, y+cellHeight/2-5, 5, 0, Math.PI*2);
                            this.ctx.arc(x+cellWidth/2+10, y+cellHeight/2-5, 5, 0, Math.PI*2);
                            this.ctx.fill();
                        }
                    }
                }
            }

            setupInputs() {
                const cellWidth = this.width/this.cols;
                const cellHeight = (this.height-50)/this.rows;
                
                this.bindEvent(this.canvas, 'click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const c = Math.floor(x/cellWidth);
                    const r = Math.floor((y-50)/cellHeight);
                    
                    if(r>=0 && r<this.rows && c>=0 && c<this.cols && this.moles[r][c]) {
                        this.moles[r][c] = null;
                        this.engine.addScore(10);
                    }
                });
            }
        }

        // ==================== 14. é’¢ç´å—/èŠ‚å¥æ¸¸æˆ ====================
        class RhythmGame extends BaseGame {
            init() {
                super.init();
                this.lanes = 4;
                this.notes = [];
                this.speed = 5;
            }

            update(deltaTime, timestamp) {
                // ç”ŸæˆéŸ³ç¬¦
                if(Math.random() < 0.02 + this.engine.level*0.005) {
                    this.notes.push({
                        lane: Math.floor(Math.random()*this.lanes),
                        y: -50
                    });
                }
                
                // æ›´æ–°éŸ³ç¬¦
                this.notes = this.notes.filter(note => {
                    note.y += this.speed + this.engine.level;
                    if(note.y > this.height) {
                        this.engine.addScore(-5);
                        return false;
                    }
                    return true;
                });
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.6)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const laneWidth = this.width/this.lanes;
                
                // è½¨é“çº¿
                this.ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                for(let i=1; i<this.lanes; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i*laneWidth, 0);
                    this.ctx.lineTo(i*laneWidth, this.height);
                    this.ctx.stroke();
                }
                
                // åˆ¤å®šçº¿
                this.ctx.fillStyle = 'rgba(255,45,149,0.5)';
                this.ctx.fillRect(0, this.height-100, this.width, 10);
                
                // éŸ³ç¬¦
                this.ctx.fillStyle = '#00f3ff';
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = '#00f3ff';
                this.notes.forEach(note => {
                    this.ctx.fillRect(note.lane*laneWidth+5, note.y, laneWidth-10, 80);
                });
                this.ctx.shadowBlur = 0;
            }

            hit(lane) {
                for(let i=0; i<this.notes.length; i++) {
                    if(this.notes[i].lane === lane && Math.abs(this.notes[i].y-(this.height-100))<50) {
                        this.notes.splice(i, 1);
                        this.engine.addScore(10);
                        return;
                    }
                }
            }

            handleInput(e) {
                if(e.key==='a' || e.key==='ArrowLeft') this.hit(0);
                if(e.key==='s') this.hit(1);
                if(e.key==='d') this.hit(2);
                if(e.key==='f' || e.key==='ArrowRight') this.hit(3);
            }

            setupInputs() {
                this.bindEvent(this.canvas, 'click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const lane = Math.floor(x/(this.width/this.lanes));
                    this.hit(lane);
                });
            }
        }

        // ==================== 15. æ¥é¸¡è›‹ ====================
        class EggCatchGame extends BaseGame {
            init() {
                super.init();
                this.reset();
            }

            reset() {
                this.basket = {x: this.width/2, width: 100, height: 20};
                this.eggs = [];
                this.lives = 3;
            }

            update(deltaTime, timestamp) {
                // ç”Ÿæˆé¸¡è›‹
                if(Math.random() < 0.01 + this.engine.level*0.002) {
                    this.eggs.push({
                        x: Math.random()*(this.width-40)+20,
                        y: -20
                    });
                }
                
                // æ›´æ–°é¸¡è›‹
                this.eggs = this.eggs.filter(egg => {
                    egg.y += 3 + this.engine.level;
                    
                    // æ¥ä½æ£€æµ‹
                    if(egg.y > this.height-70 && egg.y < this.height-50 &&
                       egg.x > this.basket.x-this.basket.width/2 && 
                       egg.x < this.basket.x+this.basket.width/2) {
                        this.engine.addScore(10);
                        return false;
                    }
                    
                    // æ‰è½
                    if(egg.y > this.height) {
                        this.lives--;
                        if(this.lives <= 0) this.engine.gameOver();
                        return false;
                    }
                    return true;
                });
                
                // é”®ç›˜æ§åˆ¶
                if(this.keys) {
                    if(this.keys['ArrowLeft']) this.basket.x -= 10;
                    if(this.keys['ArrowRight']) this.basket.x += 10;
                }
                this.basket.x = Math.max(this.basket.width/2, Math.min(this.width-this.basket.width/2, this.basket.x));
            }

            render() {
                this.ctx.fillStyle = 'rgba(135,206,235,0.3)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ç¯®å­
                this.ctx.fillStyle = '#8B4513';
                this.ctx.fillRect(this.basket.x-this.basket.width/2, this.height-50, this.basket.width, this.basket.height);
                this.ctx.fillStyle = '#39ff14';
                this.ctx.fillRect(this.basket.x-this.basket.width/2, this.height-50, this.basket.width, 5);
                
                // é¸¡è›‹
                this.ctx.fillStyle = '#fff';
                this.eggs.forEach(egg => {
                    this.ctx.beginPath();
                    this.ctx.ellipse(egg.x, egg.y, 10, 14, 0, 0, Math.PI*2);
                    this.ctx.fill();
                });
                
                // ç”Ÿå‘½
                this.ctx.fillStyle = '#ff0000';
                this.ctx.font = '24px Arial';
                this.ctx.fillText('â¤ï¸'.repeat(this.lives), 20, 40);
            }

            handleInput(e) {
                if(!this.keys) this.keys = {};
                if(e.type === 'keydown') this.keys[e.key] = true;
                if(e.type === 'keyup') this.keys[e.key] = false;
            }

            setupInputs() {
                window.addEventListener('keydown', (e) => this.handleInput(e));
                window.addEventListener('keyup', (e) => this.handleInput(e));
                this.bindings.push({element: window, event: 'keydown', handler: (e) => this.handleInput(e)});
                this.bindings.push({element: window, event: 'keyup', handler: (e) => this.handleInput(e)});
                
                this.bindEvent(this.canvas, 'touchmove', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    this.basket.x = e.touches[0].clientX - rect.left;
                });
            }
        }

        // ==================== 16. ä¹’ä¹“çƒ ====================
        class PongGame extends BaseGame {
            init() {
                super.init();
                this.reset();
            }

            reset() {
                this.ball = {x: this.width/2, y: this.height/2, dx: 4, dy: 4, radius: 10};
                this.paddle1 = {x: 20, y: this.height/2-50, width: 15, height: 100, score: 0};
                this.paddle2 = {x: this.width-35, y: this.height/2-50, width: 15, height: 100, score: 0};
            }

            update(deltaTime, timestamp) {
                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;
                
                // å¢™å£ç¢°æ’
                if(this.ball.y-this.ball.radius < 0 || this.ball.y+this.ball.radius > this.height)
                    this.ball.dy *= -1;
                
                // æŒ¡æ¿ç¢°æ’
                if(this.ball.x-this.ball.radius < this.paddle1.x+this.paddle1.width &&
                   this.ball.y > this.paddle1.y && this.ball.y < this.paddle1.y+this.paddle1.height) {
                    this.ball.dx = Math.abs(this.ball.dx);
                    this.engine.addScore(5);
                }
                if(this.ball.x+this.ball.radius > this.paddle2.x &&
                   this.ball.y > this.paddle2.y && this.ball.y < this.paddle2.y+this.paddle2.height) {
                    this.ball.dx = -Math.abs(this.ball.dx);
                }
                
                // å‡ºç•Œ
                if(this.ball.x < 0) {
                    this.paddle2.score++;
                    this.resetBall();
                }
                if(this.ball.x > this.width) {
                    this.paddle1.score++;
                    this.engine.addScore(20);
                    this.resetBall();
                }
                
                // AIæ§åˆ¶
                const target = this.ball.y - this.paddle2.height/2;
                this.paddle2.y += (target-this.paddle2.y)*0.1;
                
                // ç©å®¶é”®ç›˜æ§åˆ¶
                if(this.keys) {
                    if(this.keys['w']) this.paddle1.y -= 8;
                    if(this.keys['s']) this.paddle1.y += 8;
                }
                this.paddle1.y = Math.max(0, Math.min(this.height-this.paddle1.height, this.paddle1.y));
            }

            resetBall() {
                this.ball = {x: this.width/2, y: this.height/2, dx: 4*(Math.random()>0.5?1:-1), dy: 4*(Math.random()>0.5?1:-1), radius: 10};
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ä¸­çº¿
                this.ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                this.ctx.setLineDash([10, 10]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.width/2, 0);
                this.ctx.lineTo(this.width/2, this.height);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // çƒ
                this.ctx.fillStyle = '#fff';
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = '#fff';
                this.ctx.beginPath();
                this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI*2);
                this.ctx.fill();
                
                // æŒ¡æ¿
                this.ctx.fillStyle = '#00f3ff';
                this.ctx.fillRect(this.paddle1.x, this.paddle1.y, this.paddle1.width, this.paddle1.height);
                this.ctx.fillStyle = '#ff2d95';
                this.ctx.fillRect(this.paddle2.x, this.paddle2.y, this.paddle2.width, this.paddle2.height);
                
                // åˆ†æ•°
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '40px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(this.paddle1.score, this.width/4, 50);
                this.ctx.fillText(this.paddle2.score, this.width*3/4, 50);
                this.ctx.shadowBlur = 0;
            }

            handleInput(e) {
                if(!this.keys) this.keys = {};
                if(e.type === 'keydown') this.keys[e.key] = true;
                if(e.type === 'keyup') this.keys[e.key] = false;
            }

            setupInputs() {
                window.addEventListener('keydown', (e) => this.handleInput(e));
                window.addEventListener('keyup', (e) => this.handleInput(e));
                this.bindings.push({element: window, event: 'keydown', handler: (e) => this.handleInput(e)});
                this.bindings.push({element: window, event: 'keyup', handler: (e) => this.handleInput(e)});
                
                this.bindEvent(this.canvas, 'mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.paddle1.y = e.clientY - rect.top - this.paddle1.height/2;
                });
            }
        }

        // ==================== 17. è‰²å½©æé€Ÿ ====================
        class ColorRushGame extends BaseGame {
            init() {
                super.init();
                this.colors = ['#ff2d95','#00f3ff','#39ff14','#fff01f'];
                this.timeLeft = 30;
                this.newRound();
                this.timer = setInterval(() => {
                    if(!this.engine.isPaused) {
                        this.timeLeft--;
                        if(this.timeLeft <= 0) this.engine.gameOver();
                    }
                }, 1000);
            }

            destroy() {
                super.destroy();
                clearInterval(this.timer);
            }

            newRound() {
                this.targetColor = this.colors[Math.floor(Math.random()*this.colors.length)];
                const correct = Math.floor(Math.random()*4);
                this.blocks = this.colors.map((c,i) => ({
                    color: i===correct?this.targetColor:this.colors[Math.floor(Math.random()*this.colors.length)],
                    x: (i%2)*(this.width/2),
                    y: Math.floor(i/2)*(this.height/2)+80,
                    width: this.width/2-10,
                    height: this.height/2-90
                }));
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ç›®æ ‡é¢œè‰²
                this.ctx.fillStyle = this.targetColor;
                this.ctx.font = 'bold 40px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.shadowBlur = 30;
                this.ctx.shadowColor = this.targetColor;
                this.ctx.fillText('ç‚¹å‡»è¿™ä¸ªé¢œè‰²!', this.width/2, 50);
                this.ctx.fillText(`æ—¶é—´: ${this.timeLeft}`, this.width/2, 90);
                this.ctx.shadowBlur = 0;
                
                // è‰²å—
                this.blocks.forEach(block => {
                    const grad = this.ctx.createLinearGradient(block.x, block.y, block.x+block.width, block.y+block.height);
                    grad.addColorStop(0, block.color+'cc');
                    grad.addColorStop(1, block.color+'66');
                    this.ctx.fillStyle = grad;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = block.color;
                    this.ctx.beginPath();
                    this.ctx.roundRect(block.x+5, block.y+5, block.width-10, block.height-10, 20);
                    this.ctx.fill();
                });
                this.ctx.shadowBlur = 0;
            }

            setupInputs() {
                this.bindEvent(this.canvas, 'click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    this.blocks.forEach(block => {
                        if(x>=block.x && x<=block.x+block.width && y>=block.y && y<=block.y+block.height) {
                            if(block.color === this.targetColor) {
                                this.engine.addScore(10);
                                this.timeLeft += 2;
                                this.newRound();
                            } else {
                                this.timeLeft -= 3;
                            }
                        }
                    });
                });
            }
        }

        // ==================== 18. çº¢è­¦95ç®€åŒ–ç‰ˆ ====================
        class RedAlertGame extends BaseGame {
            init() {
                super.init();
                this.units = [];
                this.enemies = [];
                this.buildings = [{x: 50, y: this.height/2, type: 'base', hp: 500, team: 'player'}];
                this.resources = 1000;
                this.lastSpawn = 0;
            }

            update(deltaTime, timestamp) {
                // ç”Ÿæˆæ•Œäºº
                if(timestamp - this.lastSpawn > 3000 - this.engine.level*200) {
                    this.enemies.push({
                        x: this.width-50,
                        y: Math.random()*this.height,
                        hp: 50,
                        tx: this.buildings[0].x,
                        ty: this.buildings[0].y
                    });
                    this.lastSpawn = timestamp;
                }
                
                // æ›´æ–°å•ä½
                this.units.forEach(unit => {
                    // å¯»æ‰¾æœ€è¿‘çš„æ•Œäºº
                    let target = null, minDist = Infinity;
                    this.enemies.forEach(e => {
                        const d = Math.hypot(e.x-unit.x, e.y-unit.y);
                        if(d < minDist) { minDist = d; target = e; }
                    });
                    
                    if(target && minDist > 40) {
                        const dx = target.x-unit.x, dy = target.y-unit.y;
                        const dist = Math.hypot(dx, dy);
                        unit.x += (dx/dist)*2;
                        unit.y += (dy/dist)*2;
                    } else if(target) {
                        target.hp -= 2;
                    }
                });
                
                // æ›´æ–°æ•Œäºº
                this.enemies = this.enemies.filter(e => {
                    const dx = this.buildings[0].x - e.x;
                    const dy = this.buildings[0].y - e.y;
                    const dist = Math.hypot(dx, dy);
                    if(dist > 60) {
                        e.x += (dx/dist)*0.5;
                        e.y += (dy/dist)*0.5;
                    } else {
                        this.buildings[0].hp -= 1;
                        if(this.buildings[0].hp <= 0) this.engine.gameOver();
                    }
                    return e.hp > 0;
                });
                
                // èµ„æºå¢é•¿
                if(timestamp % 1000 < 20) this.resources += 1;
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,20,0,0.3)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // ç½‘æ ¼
                this.ctx.strokeStyle = 'rgba(255,255,255,0.03)';
                for(let i=0; i<this.width; i+=50) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i, this.height);
                    this.ctx.stroke();
                }
                
                // å»ºç­‘
                this.buildings.forEach(b => {
                    const grad = this.ctx.createLinearGradient(b.x-30, b.y-30, b.x+30, b.y+30);
                    grad.addColorStop(0, '#339af0');
                    grad.addColorStop(1, '#1864ab');
                    this.ctx.fillStyle = grad;
                    this.ctx.fillRect(b.x-30, b.y-30, 60, 60);
                    this.ctx.strokeStyle = '#74c0fc';
                    this.ctx.strokeRect(b.x-30, b.y-30, 60, 60);
                    
                    // è¡€æ¡
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.fillRect(b.x-30, b.y-40, 60, 5);
                    this.ctx.fillStyle = '#00ff00';
                    this.ctx.fillRect(b.x-30, b.y-40, 60*(b.hp/500), 5);
                });
                
                // å•ä½
                this.units.forEach(u => {
                    this.ctx.fillStyle = '#39ff14';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = '#39ff14';
                    this.ctx.fillRect(u.x-10, u.y-10, 20, 20);
                });
                
                // æ•Œäºº
                this.enemies.forEach(e => {
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.shadowColor = '#ff0000';
                    this.ctx.fillRect(e.x-10, e.y-10, 20, 20);
                });
                this.ctx.shadowBlur = 0;
                
                // èµ„æºæ˜¾ç¤º
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '20px Arial';
                this.ctx.fillText(`èµ„æº: ${Math.floor(this.resources)}`, 20, 30);
            }

            setupInputs() {
                this.bindEvent(this.canvas, 'click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    if(this.resources >= 50) {
                        this.units.push({x: this.buildings[0].x+50, y: this.buildings[0].y, tx: x, ty: y});
                        this.resources -= 50;
                    }
                });
            }
        }

        // ==================== 19. ç²’å­ç»˜ç”» ====================
        class ParticlesGame extends BaseGame {
            init() {
                super.init();
                this.particles = [];
                this.hue = 0;
                this.isDrawing = false;
            }

            update(deltaTime, timestamp) {
                this.particles = this.particles.filter(p => {
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.life -= 0.02;
                    p.size *= 0.95;
                    return p.life > 0;
                });
                this.hue += 2;
            }

            render() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.05)';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                this.particles.forEach(p => {
                    this.ctx.fillStyle = p.color;
                    this.ctx.globalAlpha = p.life;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    this.ctx.fill();
                });
                this.ctx.globalAlpha = 1;
            }

            addParticle(x, y) {
                for(let i=0; i<3; i++) {
                    this.particles.push({
                        x: x, y: y,
                        size: Math.random()*5+2,
                        speedX: Math.random()*4-2,
                        speedY: Math.random()*4-2,
                        color: `hsl(${this.hue},100%,50%)`,
                        life: 1
                    });
                }
            }

            setupInputs() {
                const startDraw = (e) => {
                    this.isDrawing = true;
                    const pos = e.touches ? e.touches[0] : e;
                    const rect = this.canvas.getBoundingClientRect();
                    this.addParticle(pos.clientX-rect.left, pos.clientY-rect.top);
                };
                
                const moveDraw = (e) => {
                    if(!this.isDrawing) return;
                    e.preventDefault();
                    const pos = e.touches ? e.touches[0] : e;
                    const rect = this.canvas.getBoundingClientRect();
                    this.addParticle(pos.clientX-rect.left, pos.clientY-rect.top);
                };
                
                const endDraw = () => { this.isDrawing = false; };
                
                this.bindEvent(this.canvas, 'mousedown', startDraw);
                this.bindEvent(this.canvas, 'mousemove', moveDraw);
                this.bindEvent(this.canvas, 'mouseup', endDraw);
                this.bindEvent(this.canvas, 'mouseleave', endDraw);
                this.bindEvent(this.canvas, 'touchstart', startDraw);
                this.bindEvent(this.canvas, 'touchmove', moveDraw);
                this.bindEvent(this.canvas, 'touchend', endDraw);
            }
        }

        // å¯åŠ¨å¼•æ“
        const gameEngine = new GameEngine();
    </script>
</body>
</html>
